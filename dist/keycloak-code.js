(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("keycloak-code", [], factory);
	else if(typeof exports === 'object')
		exports["keycloak-code"] = factory();
	else
		root["keycloak-code"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/keycloak.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://keycloak-code/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/js-sha256/src/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/js-sha256/src/sha256.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.9.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA256_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD =  true && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\");\n  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  ];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n\n  var blocks = [];\n\n  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (outputType, is224) {\n    return function (message) {\n      return new Sha256(is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function (is224) {\n    var method = createOutputMethod('hex', is224);\n    if (NODE_JS) {\n      method = nodeWrap(method, is224);\n    }\n    method.create = function () {\n      return new Sha256(is224);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method, is224) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var algorithm = is224 ? 'sha224' : 'sha256';\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  var createHmacOutputMethod = function (outputType, is224) {\n    return function (key, message) {\n      return new HmacSha256(key, is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createHmacMethod = function (is224) {\n    var method = createHmacOutputMethod('hex', is224);\n    method.create = function (key) {\n      return new HmacSha256(key, is224);\n    };\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  function Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    if (is224) {\n      this.h0 = 0xc1059ed8;\n      this.h1 = 0x367cd507;\n      this.h2 = 0x3070dd17;\n      this.h3 = 0xf70e5939;\n      this.h4 = 0xffc00b31;\n      this.h5 = 0x68581511;\n      this.h6 = 0x64f98fa7;\n      this.h7 = 0xbefa4fa4;\n    } else { // 256\n      this.h0 = 0x6a09e667;\n      this.h1 = 0xbb67ae85;\n      this.h2 = 0x3c6ef372;\n      this.h3 = 0xa54ff53a;\n      this.h4 = 0x510e527f;\n      this.h5 = 0x9b05688c;\n      this.h6 = 0x1f83d9ab;\n      this.h7 = 0x5be0cd19;\n    }\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n  }\n\n  Sha256.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n          blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n          blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Sha256.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,\n      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n\n    for (j = 16; j < 64; ++j) {\n      // rightrotate\n      t1 = blocks[j - 15];\n      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n      t1 = blocks[j - 2];\n      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;\n    }\n\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n      if (this.first) {\n        if (this.is224) {\n          ab = 300032;\n          t1 = blocks[0] - 1413257819;\n          h = t1 - 150054599 << 0;\n          d = t1 + 24177077 << 0;\n        } else {\n          ab = 704751109;\n          t1 = blocks[0] - 210244248;\n          h = t1 - 1521486534 << 0;\n          d = t1 + 143694565 << 0;\n        }\n        this.first = false;\n      } else {\n        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));\n        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));\n        ab = a & b;\n        maj = ab ^ (a & c) ^ bc;\n        ch = (e & f) ^ (~e & g);\n        t1 = h + s1 + ch + K[j] + blocks[j];\n        t2 = s0 + maj;\n        h = d + t1 << 0;\n        d = t1 + t2 << 0;\n      }\n      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));\n      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));\n      da = d & a;\n      maj = da ^ (d & b) ^ ab;\n      ch = (h & e) ^ (~h & f);\n      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];\n      t2 = s0 + maj;\n      g = c + t1 << 0;\n      c = t1 + t2 << 0;\n      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));\n      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));\n      cd = c & d;\n      maj = cd ^ (c & a) ^ da;\n      ch = (g & h) ^ (~g & e);\n      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];\n      t2 = s0 + maj;\n      f = b + t1 << 0;\n      b = t1 + t2 << 0;\n      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));\n      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));\n      bc = b & c;\n      maj = bc ^ (b & d) ^ cd;\n      ch = (f & g) ^ (~f & h);\n      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n      t2 = s0 + maj;\n      e = a + t1 << 0;\n      a = t1 + t2 << 0;\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n    this.h5 = this.h5 + f << 0;\n    this.h6 = this.h6 + g << 0;\n    this.h7 = this.h7 + h << 0;\n  };\n\n  Sha256.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +\n      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +\n      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +\n      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +\n      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +\n      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +\n      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +\n      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +\n      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +\n      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +\n      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +\n      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];\n    if (!this.is224) {\n      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +\n        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +\n        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +\n        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];\n    }\n    return hex;\n  };\n\n  Sha256.prototype.toString = Sha256.prototype.hex;\n\n  Sha256.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var arr = [\n      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,\n      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,\n      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,\n      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,\n      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,\n      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,\n      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF\n    ];\n    if (!this.is224) {\n      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);\n    }\n    return arr;\n  };\n\n  Sha256.prototype.array = Sha256.prototype.digest;\n\n  Sha256.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n      dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n  };\n\n  function HmacSha256(key, is224, sharedMemory) {\n    var i, type = typeof key;\n    if (type === 'string') {\n      var bytes = [], length = key.length, index = 0, code;\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = (0xc0 | (code >> 6));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = (0xe0 | (code >> 12));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));\n          bytes[index++] = (0xf0 | (code >> 18));\n          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        }\n      }\n      key = bytes;\n    } else {\n      if (type === 'object') {\n        if (key === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {\n          key = new Uint8Array(key);\n        } else if (!Array.isArray(key)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n    }\n\n    if (key.length > 64) {\n      key = (new Sha256(is224, true)).update(key).array();\n    }\n\n    var oKeyPad = [], iKeyPad = [];\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Sha256.call(this, is224, sharedMemory);\n\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n  HmacSha256.prototype = new Sha256();\n\n  HmacSha256.prototype.finalize = function () {\n    Sha256.prototype.finalize.call(this);\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Sha256.call(this, this.is224, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Sha256.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.sha256 = exports;\n  exports.sha224 = createMethod(true);\n  exports.sha256.hmac = createHmacMethod();\n  exports.sha224.hmac = createHmacMethod(true);\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    root.sha256 = exports.sha256;\n    root.sha224 = exports.sha224;\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return exports;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://keycloak-code/./node_modules/js-sha256/src/sha256.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://keycloak-code/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack://keycloak-code/(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://keycloak-code/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/keycloak.js":
/*!*************************!*\
  !*** ./src/keycloak.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\");\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(base64_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-sha256 */ \"./node_modules/js-sha256/src/sha256.js\");\n/* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_sha256__WEBPACK_IMPORTED_MODULE_1__);\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nif (typeof Promise === 'undefined') {\n  throw Error(\n    'Keycloak requires an environment that supports Promises. Make sure that you include the appropriate polyfill.',\n  );\n}\n\nlet loggedPromiseDeprecation = false;\n\nfunction logPromiseDeprecation() {\n  if (!loggedPromiseDeprecation) {\n    loggedPromiseDeprecation = true;\n    console.warn(\n      '[KEYCLOAK] Usage of legacy style promise methods such as `.error()` and `.success()` has been deprecated and support will be removed in future versions. Use standard style promise methods such as `.then() and `.catch()` instead.',\n    );\n  }\n}\n\nfunction Keycloak(config) {\n  if (!(this instanceof Keycloak)) {\n    return new Keycloak(config);\n  }\n\n  const kc = this;\n  let adapter;\n  const refreshQueue = [];\n  let callbackStorage;\n\n  const loginIframe = {\n    enable: true,\n    callbackList: [],\n    interval: 5,\n  };\n\n  const scripts = document.getElementsByTagName('script');\n  for (let i = 0; i < scripts.length; i++) {\n    if (\n      (scripts[i].src.indexOf('keycloak.js') !== -1 ||\n        scripts[i].src.indexOf('keycloak.min.js') !== -1) &&\n      scripts[i].src.indexOf('version=') !== -1\n    ) {\n      kc.iframeVersion = scripts[i].src\n        .substring(scripts[i].src.indexOf('version=') + 8)\n        .split('&')[0];\n    }\n  }\n\n  let useNonce = true;\n  const logInfo = createLogger(console.info);\n  const logWarn = createLogger(console.warn);\n\n  kc.init = function (initOptions) {\n    kc.authenticated = false;\n    kc.code = ''\n\n    callbackStorage = createCallbackStorage();\n    const adapters = ['default', 'cordova', 'cordova-native'];\n\n    if (initOptions && adapters.indexOf(initOptions.adapter) > -1) {\n      adapter = loadAdapter(initOptions.adapter);\n    } else if (initOptions && typeof initOptions.adapter === 'object') {\n      adapter = initOptions.adapter;\n    } else if (window.Cordova || window.cordova) {\n      adapter = loadAdapter('cordova');\n    } else {\n      adapter = loadAdapter();\n    }\n\n    if (initOptions) {\n      if (typeof initOptions.useNonce !== 'undefined') {\n        useNonce = initOptions.useNonce;\n      }\n\n      if (typeof initOptions.checkLoginIframe !== 'undefined') {\n        loginIframe.enable = initOptions.checkLoginIframe;\n      }\n\n      if (initOptions.checkLoginIframeInterval) {\n        loginIframe.interval = initOptions.checkLoginIframeInterval;\n      }\n\n      if (initOptions.onLoad === 'login-required') {\n        kc.loginRequired = true;\n      }\n\n      if (initOptions.responseMode) {\n        if (\n          initOptions.responseMode === 'query' ||\n          initOptions.responseMode === 'fragment'\n        ) {\n          kc.responseMode = initOptions.responseMode;\n        } else {\n          throw 'Invalid value for responseMode';\n        }\n      }\n\n      if (initOptions.flow) {\n        switch (initOptions.flow) {\n          case 'standard':\n            kc.responseType = 'code';\n            break;\n          case 'implicit':\n            kc.responseType = 'id_token token';\n            break;\n          case 'hybrid':\n            kc.responseType = 'code id_token token';\n            break;\n          default:\n            throw 'Invalid value for flow';\n        }\n        kc.flow = initOptions.flow;\n      }\n\n      if (initOptions.timeSkew != null) {\n        kc.timeSkew = initOptions.timeSkew;\n      }\n\n      if (initOptions.redirectUri) {\n        kc.redirectUri = initOptions.redirectUri;\n      }\n\n      if (initOptions.silentCheckSsoRedirectUri) {\n        kc.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n      }\n\n      if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n        kc.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n      } else {\n        kc.silentCheckSsoFallback = true;\n      }\n\n      if (initOptions.pkceMethod) {\n        if (initOptions.pkceMethod !== 'S256') {\n          throw 'Invalid value for pkceMethod';\n        }\n        kc.pkceMethod = initOptions.pkceMethod;\n      }\n\n      if (typeof initOptions.enableLogging === 'boolean') {\n        kc.enableLogging = initOptions.enableLogging;\n      } else {\n        kc.enableLogging = false;\n      }\n\n      if (typeof initOptions.scope === 'string') {\n        kc.scope = initOptions.scope;\n      }\n\n      if (\n        typeof initOptions.messageReceiveTimeout === 'number' &&\n        initOptions.messageReceiveTimeout > 0\n      ) {\n        kc.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n      } else {\n        kc.messageReceiveTimeout = 10000;\n      }\n    }\n\n    if (!kc.responseMode) {\n      kc.responseMode = 'fragment';\n    }\n    if (!kc.responseType) {\n      kc.responseType = 'code';\n      kc.flow = 'standard';\n    }\n\n    const promise = createPromise();\n\n    const initPromise = createPromise();\n    initPromise.promise\n      .then(() => {\n        kc.onReady && kc.onReady(kc.authenticated);\n        console.log('code got success')\n        promise.setSuccess(kc.code);\n      })\n      .catch((error) => {\n        promise.setError(error);\n      });\n\n    const configPromise = loadConfig(config);\n\n    function onLoad() {\n      const doLogin = function (prompt) {\n        if (!prompt) {\n          options.prompt = 'none';\n        }\n\n        kc.login(options)\n          .then(() => {\n            initPromise.setSuccess();\n          })\n          .catch((error) => {\n            initPromise.setError(error);\n          });\n      };\n\n      const checkSsoSilently = function () {\n        const ifrm = document.createElement('iframe');\n        const src = kc.createLoginUrl({\n          prompt: 'none',\n          redirectUri: kc.silentCheckSsoRedirectUri,\n        });\n        ifrm.setAttribute('src', src);\n        ifrm.setAttribute('title', 'keycloak-silent-check-sso');\n        ifrm.style.display = 'none';\n        document.body.appendChild(ifrm);\n\n        var messageCallback = function (event) {\n          if (\n            event.origin !== window.location.origin ||\n            ifrm.contentWindow !== event.source\n          ) {\n            return;\n          }\n\n          const oauth = parseCallback(event.data);\n          processCallback(oauth, initPromise);\n\n          document.body.removeChild(ifrm);\n          window.removeEventListener('message', messageCallback);\n        };\n\n        window.addEventListener('message', messageCallback);\n      };\n\n      var options = {};\n      switch (initOptions.onLoad) {\n        case 'check-sso':\n          if (loginIframe.enable) {\n            setupCheckLoginIframe().then(() => {\n              checkLoginIframe()\n                .then((unchanged) => {\n                  if (!unchanged) {\n                    kc.silentCheckSsoRedirectUri\n                      ? checkSsoSilently()\n                      : doLogin(false);\n                  } else {\n                    initPromise.setSuccess();\n                  }\n                })\n                .catch((error) => {\n                  initPromise.setError(error);\n                });\n            });\n          } else {\n            kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n          }\n          break;\n        case 'login-required':\n          doLogin(true);\n          break;\n        default:\n          throw 'Invalid value for onLoad';\n      }\n    }\n\n    function processInit() {\n      const callback = parseCallback(window.location.href);\n\n      if (callback) {\n        window.history.replaceState(\n          window.history.state,\n          null,\n          callback.newUrl,\n        );\n      }\n\n      if (callback && callback.valid) {\n        return setupCheckLoginIframe()\n          .then(() => {\n            processCallback(callback, initPromise);\n          })\n          .catch((error) => {\n            initPromise.setError(error);\n          });\n      }\n      if (initOptions) {\n        if (initOptions.token && initOptions.refreshToken) {\n          setToken(\n            initOptions.token,\n            initOptions.refreshToken,\n            initOptions.idToken,\n          );\n\n          if (loginIframe.enable) {\n            setupCheckLoginIframe().then(() => {\n              checkLoginIframe()\n                .then((unchanged) => {\n                  if (unchanged) {\n                    kc.onAuthSuccess && kc.onAuthSuccess();\n                    initPromise.setSuccess();\n                    scheduleCheckIframe();\n                  } else {\n                    initPromise.setSuccess();\n                  }\n                })\n                .catch((error) => {\n                  initPromise.setError(error);\n                });\n            });\n          } else {\n            kc.updateToken(-1)\n              .then(() => {\n                kc.onAuthSuccess && kc.onAuthSuccess();\n                initPromise.setSuccess();\n              })\n              .catch((error) => {\n                kc.onAuthError && kc.onAuthError();\n                if (initOptions.onLoad) {\n                  onLoad();\n                } else {\n                  initPromise.setError(error);\n                }\n              });\n          }\n        } else if (initOptions.onLoad) {\n          onLoad();\n        } else {\n          initPromise.setSuccess();\n        }\n      } else {\n        initPromise.setSuccess();\n      }\n    }\n\n    function domReady() {\n      const promise = createPromise();\n\n      var checkReadyState = function () {\n        if (\n          document.readyState === 'interactive' ||\n          document.readyState === 'complete'\n        ) {\n          document.removeEventListener('readystatechange', checkReadyState);\n          promise.setSuccess();\n        }\n      };\n      document.addEventListener('readystatechange', checkReadyState);\n\n      checkReadyState(); // just in case the event was already fired and we missed it (in case the init is done later than at the load time, i.e. it's done from code)\n\n      return promise.promise;\n    }\n\n    configPromise.then(() => {\n      domReady()\n        .then(processInit)\n        .catch((error) => {\n          promise.setError(error);\n        });\n    });\n    configPromise.catch((error) => {\n      promise.setError(error);\n    });\n\n    return promise.promise;\n  };\n\n  kc.login = function (options) {\n    return adapter.login(options);\n  };\n\n  function generateRandomData(len) {\n    // use web crypto APIs if possible\n    let array = null;\n    const crypto = window.crypto || window.msCrypto;\n    if (crypto && crypto.getRandomValues && window.Uint8Array) {\n      array = new Uint8Array(len);\n      crypto.getRandomValues(array);\n      return array;\n    }\n\n    // fallback to Math random\n    array = new Array(len);\n    for (let j = 0; j < array.length; j++) {\n      array[j] = Math.floor(256 * Math.random());\n    }\n    return array;\n  }\n\n  function generateCodeVerifier(len) {\n    return generateRandomString(\n      len,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',\n    );\n  }\n\n  function generateRandomString(len, alphabet) {\n    const randomData = generateRandomData(len);\n    const chars = new Array(len);\n    for (let i = 0; i < len; i++) {\n      chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n    }\n    return String.fromCharCode.apply(null, chars);\n  }\n\n  function generatePkceChallenge(pkceMethod, codeVerifier) {\n    switch (pkceMethod) {\n      // The use of the \"plain\" method is considered insecure and therefore not supported.\n      case 'S256':\n        // hash codeVerifier, then encode as url-safe base64 without padding\n        var hashBytes = new Uint8Array(js_sha256__WEBPACK_IMPORTED_MODULE_1___default.a.arrayBuffer(codeVerifier));\n        var encodedHash = base64_js__WEBPACK_IMPORTED_MODULE_0___default.a\n          .fromByteArray(hashBytes)\n          .replace(/\\+/g, '-')\n          .replace(/\\//g, '_')\n          .replace(/\\=/g, '');\n        return encodedHash;\n      default:\n        throw 'Invalid value for pkceMethod';\n    }\n  }\n\n  function buildClaimsParameter(requestedAcr) {\n    const claims = {\n      id_token: {\n        acr: requestedAcr,\n      },\n    };\n    return JSON.stringify(claims);\n  }\n\n  kc.createLoginUrl = function (options) {\n    const state = createUUID();\n    const nonce = createUUID();\n\n    const redirectUri = adapter.redirectUri(options);\n\n    const callbackState = {\n      state,\n      nonce,\n      redirectUri: encodeURIComponent(redirectUri),\n    };\n\n    if (options && options.prompt) {\n      callbackState.prompt = options.prompt;\n    }\n\n    let baseUrl;\n    if (options && options.action == 'register') {\n      baseUrl = kc.endpoints.register();\n    } else {\n      baseUrl = kc.endpoints.authorize();\n    }\n\n    let scope = (options && options.scope) || kc.scope;\n    if (!scope) {\n      // if scope is not set, default to \"openid\"\n      scope = 'openid';\n    } else if (scope.indexOf('openid') === -1) {\n      // if openid scope is missing, prefix the given scopes with it\n      scope = `openid ${scope}`;\n    }\n\n    let url = `${baseUrl}?client_id=${encodeURIComponent(\n      kc.clientId,\n    )}&redirect_uri=${encodeURIComponent(\n      redirectUri,\n    )}&state=${encodeURIComponent(state)}&response_mode=${encodeURIComponent(\n      kc.responseMode,\n    )}&response_type=${encodeURIComponent(\n      kc.responseType,\n    )}&scope=${encodeURIComponent(scope)}`;\n    if (useNonce) {\n      url = `${url}&nonce=${encodeURIComponent(nonce)}`;\n    }\n\n    if (options && options.prompt) {\n      url += `&prompt=${encodeURIComponent(options.prompt)}`;\n    }\n\n    if (options && options.maxAge) {\n      url += `&max_age=${encodeURIComponent(options.maxAge)}`;\n    }\n\n    if (options && options.loginHint) {\n      url += `&login_hint=${encodeURIComponent(options.loginHint)}`;\n    }\n\n    if (options && options.idpHint) {\n      url += `&kc_idp_hint=${encodeURIComponent(options.idpHint)}`;\n    }\n\n    if (options && options.action && options.action != 'register') {\n      url += `&kc_action=${encodeURIComponent(options.action)}`;\n    }\n\n    if (options && options.locale) {\n      url += `&ui_locales=${encodeURIComponent(options.locale)}`;\n    }\n\n    if (options && options.acr) {\n      const claimsParameter = buildClaimsParameter(options.acr);\n      url += `&claims=${encodeURIComponent(claimsParameter)}`;\n    }\n\n    if (kc.pkceMethod) {\n      const codeVerifier = generateCodeVerifier(96);\n      callbackState.pkceCodeVerifier = codeVerifier;\n      const pkceChallenge = generatePkceChallenge(kc.pkceMethod, codeVerifier);\n      url += `&code_challenge=${pkceChallenge}`;\n      url += `&code_challenge_method=${kc.pkceMethod}`;\n    }\n\n    callbackStorage.add(callbackState);\n\n    return url;\n  };\n\n  kc.logout = function (options) {\n    return adapter.logout(options);\n  };\n\n  kc.createLogoutUrl = function (options) {\n    const url = `${kc.endpoints.logout()}?post_logout_redirect_uri=${encodeURIComponent(\n      adapter.redirectUri(options, false),\n    )}&id_token_hint=${encodeURIComponent(kc.idToken)}`;\n\n    return url;\n  };\n\n  kc.register = function (options) {\n    return adapter.register(options);\n  };\n\n  kc.createRegisterUrl = function (options) {\n    if (!options) {\n      options = {};\n    }\n    options.action = 'register';\n    return kc.createLoginUrl(options);\n  };\n\n  kc.createAccountUrl = function (options) {\n    const realm = getRealmUrl();\n    let url;\n    if (typeof realm !== 'undefined') {\n      url =\n        `${realm}/account` +\n        `?referrer=${encodeURIComponent(\n          kc.clientId,\n        )}&referrer_uri=${encodeURIComponent(adapter.redirectUri(options))}`;\n    }\n    return url;\n  };\n\n  kc.accountManagement = function () {\n    return adapter.accountManagement();\n  };\n\n  kc.hasRealmRole = function (role) {\n    const access = kc.realmAccess;\n    return !!access && access.roles.indexOf(role) >= 0;\n  };\n\n  kc.hasResourceRole = function (role, resource) {\n    if (!kc.resourceAccess) {\n      return false;\n    }\n\n    const access = kc.resourceAccess[resource || kc.clientId];\n    return !!access && access.roles.indexOf(role) >= 0;\n  };\n\n  kc.loadUserProfile = function () {\n    const url = `${getRealmUrl()}/account`;\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n    req.setRequestHeader('Authorization', `bearer ${kc.token}`);\n\n    const promise = createPromise();\n\n    req.onreadystatechange = function () {\n      if (req.readyState == 4) {\n        if (req.status == 200) {\n          kc.profile = JSON.parse(req.responseText);\n          promise.setSuccess(kc.profile);\n        } else {\n          promise.setError();\n        }\n      }\n    };\n\n    req.send();\n\n    return promise.promise;\n  };\n\n  kc.loadUserInfo = function () {\n    const url = kc.endpoints.userinfo();\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n    req.setRequestHeader('Authorization', `bearer ${kc.token}`);\n\n    const promise = createPromise();\n\n    req.onreadystatechange = function () {\n      if (req.readyState == 4) {\n        if (req.status == 200) {\n          kc.userInfo = JSON.parse(req.responseText);\n          promise.setSuccess(kc.userInfo);\n        } else {\n          promise.setError();\n        }\n      }\n    };\n\n    req.send();\n\n    return promise.promise;\n  };\n\n  kc.isTokenExpired = function (minValidity) {\n    if (!kc.tokenParsed || (!kc.refreshToken && kc.flow != 'implicit')) {\n      throw 'Not authenticated';\n    }\n\n    if (kc.timeSkew == null) {\n      logInfo(\n        '[KEYCLOAK] Unable to determine if token is expired as timeskew is not set',\n      );\n      return true;\n    }\n\n    let expiresIn =\n      kc.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + kc.timeSkew;\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw 'Invalid minValidity';\n      }\n      expiresIn -= minValidity;\n    }\n    return expiresIn < 0;\n  };\n\n  kc.updateToken = function (minValidity) {\n    const promise = createPromise();\n\n    if (!kc.refreshToken) {\n      promise.setError();\n      return promise.promise;\n    }\n\n    minValidity = minValidity || 5;\n\n    const exec = function () {\n      let refreshToken = false;\n      if (minValidity == -1) {\n        refreshToken = true;\n        logInfo('[KEYCLOAK] Refreshing token: forced refresh');\n      } else if (!kc.tokenParsed || kc.isTokenExpired(minValidity)) {\n        refreshToken = true;\n        logInfo('[KEYCLOAK] Refreshing token: token expired');\n      }\n\n      if (!refreshToken) {\n        promise.setSuccess(false);\n      } else {\n        let params =\n          `grant_type=refresh_token&` + `refresh_token=${kc.refreshToken}`;\n        const url = kc.endpoints.token();\n\n        refreshQueue.push(promise);\n\n        if (refreshQueue.length == 1) {\n          const req = new XMLHttpRequest();\n          req.open('POST', url, true);\n          req.setRequestHeader(\n            'Content-type',\n            'application/x-www-form-urlencoded',\n          );\n          req.withCredentials = true;\n\n          params += `&client_id=${encodeURIComponent(kc.clientId)}`;\n\n          let timeLocal = new Date().getTime();\n\n          req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n              if (req.status == 200) {\n                logInfo('[KEYCLOAK] Token refreshed');\n\n                timeLocal = (timeLocal + new Date().getTime()) / 2;\n\n                const tokenResponse = JSON.parse(req.responseText);\n\n                setToken(\n                  tokenResponse.access_token,\n                  tokenResponse.refresh_token,\n                  tokenResponse.id_token,\n                  timeLocal,\n                );\n\n                kc.onAuthRefreshSuccess && kc.onAuthRefreshSuccess();\n                for (\n                  var p = refreshQueue.pop();\n                  p != null;\n                  p = refreshQueue.pop()\n                ) {\n                  p.setSuccess(true);\n                }\n              } else {\n                logWarn('[KEYCLOAK] Failed to refresh token');\n\n                if (req.status == 400) {\n                  kc.clearToken();\n                }\n\n                kc.onAuthRefreshError && kc.onAuthRefreshError();\n                for (\n                  var p = refreshQueue.pop();\n                  p != null;\n                  p = refreshQueue.pop()\n                ) {\n                  p.setError(true);\n                }\n              }\n            }\n          };\n\n          req.send(params);\n        }\n      }\n    };\n\n    if (loginIframe.enable) {\n      const iframePromise = checkLoginIframe();\n      iframePromise\n        .then(() => {\n          exec();\n        })\n        .catch((error) => {\n          promise.setError(error);\n        });\n    } else {\n      exec();\n    }\n\n    return promise.promise;\n  };\n\n  kc.clearToken = function () {\n    if (kc.token) {\n      setToken(null, null, null);\n      kc.onAuthLogout && kc.onAuthLogout();\n      if (kc.loginRequired) {\n        kc.login();\n      }\n    }\n  };\n\n  function getRealmUrl() {\n    if (typeof kc.authServerUrl !== 'undefined') {\n      if (kc.authServerUrl.charAt(kc.authServerUrl.length - 1) == '/') {\n        return `${kc.authServerUrl}realms/${encodeURIComponent(kc.realm)}`;\n      }\n      return `${kc.authServerUrl}/realms/${encodeURIComponent(kc.realm)}`;\n    }\n    return undefined;\n  }\n\n  function getOrigin() {\n    if (!window.location.origin) {\n      return `${window.location.protocol}//${window.location.hostname}${\n        window.location.port ? `:${window.location.port}` : ''\n      }`;\n    }\n    return window.location.origin;\n  }\n\n  function processCallback(oauth, promise) {\n    const { code } = oauth;\n    const { error } = oauth;\n    const { prompt } = oauth;\n\n    let timeLocal = new Date().getTime();\n\n    if (oauth.kc_action_status) {\n      kc.onActionUpdate && kc.onActionUpdate(oauth.kc_action_status);\n    }\n\n    if (error) {\n      if (prompt != 'none') {\n        const errorData = {\n          error,\n          error_description: oauth.error_description,\n        };\n        kc.onAuthError && kc.onAuthError(errorData);\n        promise && promise.setError(errorData);\n      } else {\n        promise && promise.setSuccess();\n      }\n      return;\n    }\n    if (kc.flow != 'standard' && (oauth.access_token || oauth.id_token)) {\n      authSuccess(oauth.access_token, null, oauth.id_token, true);\n    }\n\n    if (kc.flow != 'implicit' && code) {\n      kc.code = code;\n      kc.onAuthSuccess && kc.onAuthSuccess();\n      promise && promise.setSuccess();\n      // let params = `code=${code}&grant_type=authorization_code`;\n      // const url = kc.endpoints.token();\n\n      // const req = new XMLHttpRequest();\n      // req.open('POST', url, true);\n      // req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\n      // params += `&client_id=${encodeURIComponent(kc.clientId)}`;\n      // params += `&redirect_uri=${oauth.redirectUri}`;\n\n      // if (oauth.pkceCodeVerifier) {\n      //   params += `&code_verifier=${oauth.pkceCodeVerifier}`;\n      // }\n\n      // req.withCredentials = true;\n\n      // req.onreadystatechange = function () {\n      //   if (req.readyState == 4) {\n      //     if (req.status == 200) {\n      //       const tokenResponse = JSON.parse(req.responseText);\n      //       authSuccess(\n      //         tokenResponse.access_token,\n      //         tokenResponse.refresh_token,\n      //         tokenResponse.id_token,\n      //         kc.flow === 'standard',\n      //       );\n      //       scheduleCheckIframe();\n      //     } else {\n      //       kc.onAuthError && kc.onAuthError();\n      //       promise && promise.setError();\n      //     }\n      //   }\n      // };\n\n      // req.send(params);\n    }\n\n    function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {\n      timeLocal = (timeLocal + new Date().getTime()) / 2;\n\n      setToken(accessToken, refreshToken, idToken, timeLocal);\n\n      if (\n        useNonce &&\n        ((kc.tokenParsed && kc.tokenParsed.nonce != oauth.storedNonce) ||\n          (kc.refreshTokenParsed &&\n            kc.refreshTokenParsed.nonce != oauth.storedNonce) ||\n          (kc.idTokenParsed && kc.idTokenParsed.nonce != oauth.storedNonce))\n      ) {\n        logInfo('[KEYCLOAK] Invalid nonce, clearing token');\n        kc.clearToken();\n        promise && promise.setError();\n      } else if (fulfillPromise) {\n        kc.onAuthSuccess && kc.onAuthSuccess();\n        promise && promise.setSuccess();\n      }\n    }\n  }\n\n  function loadConfig(url) {\n    const promise = createPromise();\n    let configUrl;\n\n    if (!config) {\n      configUrl = 'keycloak.json';\n    } else if (typeof config === 'string') {\n      configUrl = config;\n    }\n\n    function setupOidcEndoints(oidcConfiguration) {\n      if (!oidcConfiguration) {\n        kc.endpoints = {\n          authorize() {\n            return `${getRealmUrl()}/protocol/openid-connect/auth`;\n          },\n          token() {\n            return `${getRealmUrl()}/protocol/openid-connect/token`;\n          },\n          logout() {\n            return `${getRealmUrl()}/protocol/openid-connect/logout`;\n          },\n          checkSessionIframe() {\n            let src = `${getRealmUrl()}/protocol/openid-connect/login-status-iframe.html`;\n            if (kc.iframeVersion) {\n              src = `${src}?version=${kc.iframeVersion}`;\n            }\n            return src;\n          },\n          thirdPartyCookiesIframe() {\n            let src = `${getRealmUrl()}/protocol/openid-connect/3p-cookies/step1.html`;\n            if (kc.iframeVersion) {\n              src = `${src}?version=${kc.iframeVersion}`;\n            }\n            return src;\n          },\n          register() {\n            return `${getRealmUrl()}/protocol/openid-connect/registrations`;\n          },\n          userinfo() {\n            return `${getRealmUrl()}/protocol/openid-connect/userinfo`;\n          },\n        };\n      } else {\n        kc.endpoints = {\n          authorize() {\n            return oidcConfiguration.authorization_endpoint;\n          },\n          token() {\n            return oidcConfiguration.token_endpoint;\n          },\n          logout() {\n            if (!oidcConfiguration.end_session_endpoint) {\n              throw 'Not supported by the OIDC server';\n            }\n            return oidcConfiguration.end_session_endpoint;\n          },\n          checkSessionIframe() {\n            if (!oidcConfiguration.check_session_iframe) {\n              throw 'Not supported by the OIDC server';\n            }\n            return oidcConfiguration.check_session_iframe;\n          },\n          register() {\n            throw 'Redirection to \"Register user\" page not supported in standard OIDC mode';\n          },\n          userinfo() {\n            if (!oidcConfiguration.userinfo_endpoint) {\n              throw 'Not supported by the OIDC server';\n            }\n            return oidcConfiguration.userinfo_endpoint;\n          },\n        };\n      }\n    }\n\n    if (configUrl) {\n      var req = new XMLHttpRequest();\n      req.open('GET', configUrl, true);\n      req.setRequestHeader('Accept', 'application/json');\n\n      req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n          if (req.status == 200 || fileLoaded(req)) {\n            const config = JSON.parse(req.responseText);\n\n            kc.authServerUrl = config['auth-server-url'];\n            kc.realm = config.realm;\n            kc.clientId = config.resource;\n            setupOidcEndoints(null);\n            promise.setSuccess();\n          } else {\n            promise.setError();\n          }\n        }\n      };\n\n      req.send();\n    } else {\n      if (!config.clientId) {\n        throw 'clientId missing';\n      }\n\n      kc.clientId = config.clientId;\n\n      const { oidcProvider } = config;\n      if (!oidcProvider) {\n        if (!config.url) {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            if (scripts[i].src.match(/.*keycloak\\.js/)) {\n              config.url = scripts[i].src.substr(\n                0,\n                scripts[i].src.indexOf('/js/keycloak.js'),\n              );\n              break;\n            }\n          }\n        }\n        if (!config.realm) {\n          throw 'realm missing';\n        }\n\n        kc.authServerUrl = config.url;\n        kc.realm = config.realm;\n        setupOidcEndoints(null);\n        promise.setSuccess();\n      } else if (typeof oidcProvider === 'string') {\n        let oidcProviderConfigUrl;\n        if (oidcProvider.charAt(oidcProvider.length - 1) == '/') {\n          oidcProviderConfigUrl = `${oidcProvider}.well-known/openid-configuration`;\n        } else {\n          oidcProviderConfigUrl = `${oidcProvider}/.well-known/openid-configuration`;\n        }\n        var req = new XMLHttpRequest();\n        req.open('GET', oidcProviderConfigUrl, true);\n        req.setRequestHeader('Accept', 'application/json');\n\n        req.onreadystatechange = function () {\n          if (req.readyState == 4) {\n            if (req.status == 200 || fileLoaded(req)) {\n              const oidcProviderConfig = JSON.parse(req.responseText);\n              setupOidcEndoints(oidcProviderConfig);\n              promise.setSuccess();\n            } else {\n              promise.setError();\n            }\n          }\n        };\n\n        req.send();\n      } else {\n        setupOidcEndoints(oidcProvider);\n        promise.setSuccess();\n      }\n    }\n\n    return promise.promise;\n  }\n\n  function fileLoaded(xhr) {\n    return (\n      xhr.status == 0 && xhr.responseText && xhr.responseURL.startsWith('file:')\n    );\n  }\n\n  function setToken(token, refreshToken, idToken, timeLocal) {\n    if (kc.tokenTimeoutHandle) {\n      clearTimeout(kc.tokenTimeoutHandle);\n      kc.tokenTimeoutHandle = null;\n    }\n\n    if (refreshToken) {\n      kc.refreshToken = refreshToken;\n      kc.refreshTokenParsed = decodeToken(refreshToken);\n    } else {\n      delete kc.refreshToken;\n      delete kc.refreshTokenParsed;\n    }\n\n    if (idToken) {\n      kc.idToken = idToken;\n      kc.idTokenParsed = decodeToken(idToken);\n    } else {\n      delete kc.idToken;\n      delete kc.idTokenParsed;\n    }\n\n    if (token) {\n      kc.token = token;\n      kc.tokenParsed = decodeToken(token);\n      kc.sessionId = kc.tokenParsed.session_state;\n      kc.authenticated = true;\n      kc.subject = kc.tokenParsed.sub;\n      kc.realmAccess = kc.tokenParsed.realm_access;\n      kc.resourceAccess = kc.tokenParsed.resource_access;\n\n      if (timeLocal) {\n        kc.timeSkew = Math.floor(timeLocal / 1000) - kc.tokenParsed.iat;\n      }\n\n      if (kc.timeSkew != null) {\n        logInfo(\n          `[KEYCLOAK] Estimated time difference between browser and server is ${kc.timeSkew} seconds`,\n        );\n\n        if (kc.onTokenExpired) {\n          const expiresIn =\n            (kc.tokenParsed.exp - new Date().getTime() / 1000 + kc.timeSkew) *\n            1000;\n          logInfo(\n            `[KEYCLOAK] Token expires in ${Math.round(expiresIn / 1000)} s`,\n          );\n          if (expiresIn <= 0) {\n            kc.onTokenExpired();\n          } else {\n            kc.tokenTimeoutHandle = setTimeout(kc.onTokenExpired, expiresIn);\n          }\n        }\n      }\n    } else {\n      delete kc.token;\n      delete kc.tokenParsed;\n      delete kc.subject;\n      delete kc.realmAccess;\n      delete kc.resourceAccess;\n\n      kc.authenticated = false;\n    }\n  }\n\n  function decodeToken(str) {\n    str = str.split('.')[1];\n\n    str = str.replace(/-/g, '+');\n    str = str.replace(/_/g, '/');\n    switch (str.length % 4) {\n      case 0:\n        break;\n      case 2:\n        str += '==';\n        break;\n      case 3:\n        str += '=';\n        break;\n      default:\n        throw 'Invalid token';\n    }\n\n    str = decodeURIComponent(escape(atob(str)));\n\n    str = JSON.parse(str);\n    return str;\n  }\n\n  function createUUID() {\n    const hexDigits = '0123456789abcdef';\n    const s = generateRandomString(36, hexDigits).split('');\n    s[14] = '4';\n    s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);\n    s[8] = s[13] = s[18] = s[23] = '-';\n    const uuid = s.join('');\n    return uuid;\n  }\n\n  function parseCallback(url) {\n    const oauth = parseCallbackUrl(url);\n    if (!oauth) {\n      return;\n    }\n\n    const oauthState = callbackStorage.get(oauth.state);\n\n    if (oauthState) {\n      oauth.valid = true;\n      oauth.redirectUri = oauthState.redirectUri;\n      oauth.storedNonce = oauthState.nonce;\n      oauth.prompt = oauthState.prompt;\n      oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n    }\n\n    return oauth;\n  }\n\n  function parseCallbackUrl(url) {\n    let supportedParams;\n    switch (kc.flow) {\n      case 'standard':\n        supportedParams = [\n          'code',\n          'state',\n          'session_state',\n          'kc_action_status',\n        ];\n        break;\n      case 'implicit':\n        supportedParams = [\n          'access_token',\n          'token_type',\n          'id_token',\n          'state',\n          'session_state',\n          'expires_in',\n          'kc_action_status',\n        ];\n        break;\n      case 'hybrid':\n        supportedParams = [\n          'access_token',\n          'token_type',\n          'id_token',\n          'code',\n          'state',\n          'session_state',\n          'expires_in',\n          'kc_action_status',\n        ];\n        break;\n    }\n\n    supportedParams.push('error');\n    supportedParams.push('error_description');\n    supportedParams.push('error_uri');\n\n    const queryIndex = url.indexOf('?');\n    const fragmentIndex = url.indexOf('#');\n\n    let newUrl;\n    let parsed;\n\n    if (kc.responseMode === 'query' && queryIndex !== -1) {\n      newUrl = url.substring(0, queryIndex);\n      parsed = parseCallbackParams(\n        url.substring(\n          queryIndex + 1,\n          fragmentIndex !== -1 ? fragmentIndex : url.length,\n        ),\n        supportedParams,\n      );\n      if (parsed.paramsString !== '') {\n        newUrl += `?${parsed.paramsString}`;\n      }\n      if (fragmentIndex !== -1) {\n        newUrl += url.substring(fragmentIndex);\n      }\n    } else if (kc.responseMode === 'fragment' && fragmentIndex !== -1) {\n      newUrl = url.substring(0, fragmentIndex);\n      parsed = parseCallbackParams(\n        url.substring(fragmentIndex + 1),\n        supportedParams,\n      );\n      if (parsed.paramsString !== '') {\n        newUrl += `#${parsed.paramsString}`;\n      }\n    }\n\n    if (parsed && parsed.oauthParams) {\n      if (kc.flow === 'standard' || kc.flow === 'hybrid') {\n        if (\n          (parsed.oauthParams.code || parsed.oauthParams.error) &&\n          parsed.oauthParams.state\n        ) {\n          parsed.oauthParams.newUrl = newUrl;\n          return parsed.oauthParams;\n        }\n      } else if (kc.flow === 'implicit') {\n        if (\n          (parsed.oauthParams.access_token || parsed.oauthParams.error) &&\n          parsed.oauthParams.state\n        ) {\n          parsed.oauthParams.newUrl = newUrl;\n          return parsed.oauthParams;\n        }\n      }\n    }\n  }\n\n  function parseCallbackParams(paramsString, supportedParams) {\n    const p = paramsString.split('&');\n    const result = {\n      paramsString: '',\n      oauthParams: {},\n    };\n    for (let i = 0; i < p.length; i++) {\n      const split = p[i].indexOf('=');\n      const key = p[i].slice(0, split);\n      if (supportedParams.indexOf(key) !== -1) {\n        result.oauthParams[key] = p[i].slice(split + 1);\n      } else {\n        if (result.paramsString !== '') {\n          result.paramsString += '&';\n        }\n        result.paramsString += p[i];\n      }\n    }\n    return result;\n  }\n\n  function createPromise() {\n    // Need to create a native Promise which also preserves the\n    // interface of the custom promise type previously used by the API\n    var p = {\n      setSuccess(result) {\n        p.resolve(result);\n      },\n\n      setError(result) {\n        p.reject(result);\n      },\n    };\n    p.promise = new Promise((resolve, reject) => {\n      p.resolve = resolve;\n      p.reject = reject;\n    });\n\n    p.promise.success = function (callback) {\n      logPromiseDeprecation();\n\n      this.then((value) => {\n        callback(value);\n      });\n\n      return this;\n    };\n\n    p.promise.error = function (callback) {\n      logPromiseDeprecation();\n\n      this.catch((error) => {\n        callback(error);\n      });\n\n      return this;\n    };\n\n    return p;\n  }\n\n  // Function to extend existing native Promise with timeout\n  function applyTimeoutToPromise(promise, timeout, errorMessage) {\n    let timeoutHandle = null;\n    const timeoutPromise = new Promise((resolve, reject) => {\n      timeoutHandle = setTimeout(() => {\n        reject({\n          error:\n            errorMessage ||\n            `Promise is not settled within timeout of ${timeout}ms`,\n        });\n      }, timeout);\n    });\n\n    return Promise.race([promise, timeoutPromise]).finally(() => {\n      clearTimeout(timeoutHandle);\n    });\n  }\n\n  function setupCheckLoginIframe() {\n    const promise = createPromise();\n\n    if (!loginIframe.enable) {\n      promise.setSuccess();\n      return promise.promise;\n    }\n\n    if (loginIframe.iframe) {\n      promise.setSuccess();\n      return promise.promise;\n    }\n\n    const iframe = document.createElement('iframe');\n    loginIframe.iframe = iframe;\n\n    iframe.onload = function () {\n      const authUrl = kc.endpoints.authorize();\n      if (authUrl.charAt(0) === '/') {\n        loginIframe.iframeOrigin = getOrigin();\n      } else {\n        loginIframe.iframeOrigin = authUrl.substring(\n          0,\n          authUrl.indexOf('/', 8),\n        );\n      }\n      promise.setSuccess();\n    };\n\n    const src = kc.endpoints.checkSessionIframe();\n    iframe.setAttribute('src', src);\n    iframe.setAttribute('title', 'keycloak-session-iframe');\n    iframe.style.display = 'none';\n    document.body.appendChild(iframe);\n\n    const messageCallback = function (event) {\n      if (\n        event.origin !== loginIframe.iframeOrigin ||\n        loginIframe.iframe.contentWindow !== event.source\n      ) {\n        return;\n      }\n\n      if (\n        !(\n          event.data == 'unchanged' ||\n          event.data == 'changed' ||\n          event.data == 'error'\n        )\n      ) {\n        return;\n      }\n\n      if (event.data != 'unchanged') {\n        kc.clearToken();\n      }\n\n      const callbacks = loginIframe.callbackList.splice(\n        0,\n        loginIframe.callbackList.length,\n      );\n\n      for (let i = callbacks.length - 1; i >= 0; --i) {\n        const promise = callbacks[i];\n        if (event.data == 'error') {\n          promise.setError();\n        } else {\n          promise.setSuccess(event.data == 'unchanged');\n        }\n      }\n    };\n\n    window.addEventListener('message', messageCallback, false);\n\n    return promise.promise;\n  }\n\n  function scheduleCheckIframe() {\n    if (loginIframe.enable) {\n      if (kc.token) {\n        setTimeout(() => {\n          checkLoginIframe().then((unchanged) => {\n            if (unchanged) {\n              scheduleCheckIframe();\n            }\n          });\n        }, loginIframe.interval * 1000);\n      }\n    }\n  }\n\n  function checkLoginIframe() {\n    const promise = createPromise();\n\n    if (loginIframe.iframe && loginIframe.iframeOrigin) {\n      const msg = `${kc.clientId} ${kc.sessionId ? kc.sessionId : ''}`;\n      loginIframe.callbackList.push(promise);\n      const origin = loginIframe.iframeOrigin;\n      if (loginIframe.callbackList.length == 1) {\n        loginIframe.iframe.contentWindow.postMessage(msg, origin);\n      }\n    } else {\n      promise.setSuccess();\n    }\n\n    return promise.promise;\n  }\n\n  function check3pCookiesSupported() {\n    const promise = createPromise();\n\n    if (loginIframe.enable || kc.silentCheckSsoRedirectUri) {\n      const iframe = document.createElement('iframe');\n      iframe.setAttribute('src', kc.endpoints.thirdPartyCookiesIframe());\n      iframe.setAttribute('title', 'keycloak-3p-check-iframe');\n      iframe.style.display = 'none';\n      document.body.appendChild(iframe);\n\n      var messageCallback = function (event) {\n        if (iframe.contentWindow !== event.source) {\n          return;\n        }\n\n        if (event.data !== 'supported' && event.data !== 'unsupported') {\n          return;\n        }\n        if (event.data === 'unsupported') {\n          loginIframe.enable = false;\n          if (kc.silentCheckSsoFallback) {\n            kc.silentCheckSsoRedirectUri = false;\n          }\n          logWarn(\n            \"[KEYCLOAK] 3rd party cookies aren't supported by this browser. checkLoginIframe and \" +\n              'silent check-sso are not available.',\n          );\n        }\n\n        document.body.removeChild(iframe);\n        window.removeEventListener('message', messageCallback);\n        promise.setSuccess();\n      };\n\n      window.addEventListener('message', messageCallback, false);\n    } else {\n      promise.setSuccess();\n    }\n\n    return applyTimeoutToPromise(\n      promise.promise,\n      kc.messageReceiveTimeout,\n      'Timeout when waiting for 3rd party check iframe message.',\n    );\n  }\n\n  function loadAdapter(type) {\n    if (!type || type == 'default') {\n      return {\n        login(options) {\n          window.location.replace(kc.createLoginUrl(options));\n          return createPromise().promise;\n        },\n\n        logout(options) {\n          window.location.replace(kc.createLogoutUrl(options));\n          return createPromise().promise;\n        },\n\n        register(options) {\n          window.location.replace(kc.createRegisterUrl(options));\n          return createPromise().promise;\n        },\n\n        accountManagement() {\n          const accountUrl = kc.createAccountUrl();\n          if (typeof accountUrl !== 'undefined') {\n            window.location.href = accountUrl;\n          } else {\n            throw 'Not supported by the OIDC server';\n          }\n          return createPromise().promise;\n        },\n\n        redirectUri(options, encodeHash) {\n          if (arguments.length == 1) {\n            encodeHash = true;\n          }\n\n          if (options && options.redirectUri) {\n            return options.redirectUri;\n          }\n          if (kc.redirectUri) {\n            return kc.redirectUri;\n          }\n          return location.href;\n        },\n      };\n    }\n\n    if (type == 'cordova') {\n      loginIframe.enable = false;\n      const cordovaOpenWindowWrapper = function (loginUrl, target, options) {\n        if (window.cordova && window.cordova.InAppBrowser) {\n          // Use inappbrowser for IOS and Android if available\n          return window.cordova.InAppBrowser.open(loginUrl, target, options);\n        }\n        return window.open(loginUrl, target, options);\n      };\n\n      const shallowCloneCordovaOptions = function (userOptions) {\n        if (userOptions && userOptions.cordovaOptions) {\n          return Object.keys(userOptions.cordovaOptions).reduce(\n            (options, optionName) => {\n              options[optionName] = userOptions.cordovaOptions[optionName];\n              return options;\n            },\n            {},\n          );\n        }\n        return {};\n      };\n\n      const formatCordovaOptions = function (cordovaOptions) {\n        return Object.keys(cordovaOptions)\n          .reduce((options, optionName) => {\n            options.push(`${optionName}=${cordovaOptions[optionName]}`);\n            return options;\n          }, [])\n          .join(',');\n      };\n\n      const createCordovaOptions = function (userOptions) {\n        const cordovaOptions = shallowCloneCordovaOptions(userOptions);\n        cordovaOptions.location = 'no';\n        if (userOptions && userOptions.prompt == 'none') {\n          cordovaOptions.hidden = 'yes';\n        }\n        return formatCordovaOptions(cordovaOptions);\n      };\n\n      return {\n        login(options) {\n          const promise = createPromise();\n\n          const cordovaOptions = createCordovaOptions(options);\n          const loginUrl = kc.createLoginUrl(options);\n          const ref = cordovaOpenWindowWrapper(\n            loginUrl,\n            '_blank',\n            cordovaOptions,\n          );\n          let completed = false;\n\n          let closed = false;\n          const closeBrowser = function () {\n            closed = true;\n            ref.close();\n          };\n\n          ref.addEventListener('loadstart', (event) => {\n            if (event.url.indexOf('http://localhost') == 0) {\n              const callback = parseCallback(event.url);\n              processCallback(callback, promise);\n              closeBrowser();\n              completed = true;\n            }\n          });\n\n          ref.addEventListener('loaderror', (event) => {\n            if (!completed) {\n              if (event.url.indexOf('http://localhost') == 0) {\n                const callback = parseCallback(event.url);\n                processCallback(callback, promise);\n                closeBrowser();\n                completed = true;\n              } else {\n                promise.setError();\n                closeBrowser();\n              }\n            }\n          });\n\n          ref.addEventListener('exit', (event) => {\n            if (!closed) {\n              promise.setError({\n                reason: 'closed_by_user',\n              });\n            }\n          });\n\n          return promise.promise;\n        },\n\n        logout(options) {\n          const promise = createPromise();\n\n          const logoutUrl = kc.createLogoutUrl(options);\n          const ref = cordovaOpenWindowWrapper(\n            logoutUrl,\n            '_blank',\n            'location=no,hidden=yes,clearcache=yes',\n          );\n\n          let error;\n\n          ref.addEventListener('loadstart', (event) => {\n            if (event.url.indexOf('http://localhost') == 0) {\n              ref.close();\n            }\n          });\n\n          ref.addEventListener('loaderror', (event) => {\n            if (event.url.indexOf('http://localhost') == 0) {\n              ref.close();\n            } else {\n              error = true;\n              ref.close();\n            }\n          });\n\n          ref.addEventListener('exit', (event) => {\n            if (error) {\n              promise.setError();\n            } else {\n              kc.clearToken();\n              promise.setSuccess();\n            }\n          });\n\n          return promise.promise;\n        },\n\n        register(options) {\n          const promise = createPromise();\n          const registerUrl = kc.createRegisterUrl();\n          const cordovaOptions = createCordovaOptions(options);\n          const ref = cordovaOpenWindowWrapper(\n            registerUrl,\n            '_blank',\n            cordovaOptions,\n          );\n          ref.addEventListener('loadstart', (event) => {\n            if (event.url.indexOf('http://localhost') == 0) {\n              ref.close();\n              const oauth = parseCallback(event.url);\n              processCallback(oauth, promise);\n            }\n          });\n          return promise.promise;\n        },\n\n        accountManagement() {\n          const accountUrl = kc.createAccountUrl();\n          if (typeof accountUrl !== 'undefined') {\n            const ref = cordovaOpenWindowWrapper(\n              accountUrl,\n              '_blank',\n              'location=no',\n            );\n            ref.addEventListener('loadstart', (event) => {\n              if (event.url.indexOf('http://localhost') == 0) {\n                ref.close();\n              }\n            });\n          } else {\n            throw 'Not supported by the OIDC server';\n          }\n        },\n\n        redirectUri(options) {\n          return 'http://localhost';\n        },\n      };\n    }\n\n    if (type == 'cordova-native') {\n      loginIframe.enable = false;\n\n      return {\n        login(options) {\n          const promise = createPromise();\n          const loginUrl = kc.createLoginUrl(options);\n\n          universalLinks.subscribe('keycloak', (event) => {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            const oauth = parseCallback(event.url);\n            processCallback(oauth, promise);\n          });\n\n          window.cordova.plugins.browsertab.openUrl(loginUrl);\n          return promise.promise;\n        },\n\n        logout(options) {\n          const promise = createPromise();\n          const logoutUrl = kc.createLogoutUrl(options);\n\n          universalLinks.subscribe('keycloak', (event) => {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            kc.clearToken();\n            promise.setSuccess();\n          });\n\n          window.cordova.plugins.browsertab.openUrl(logoutUrl);\n          return promise.promise;\n        },\n\n        register(options) {\n          const promise = createPromise();\n          const registerUrl = kc.createRegisterUrl(options);\n          universalLinks.subscribe('keycloak', (event) => {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            const oauth = parseCallback(event.url);\n            processCallback(oauth, promise);\n          });\n          window.cordova.plugins.browsertab.openUrl(registerUrl);\n          return promise.promise;\n        },\n\n        accountManagement() {\n          const accountUrl = kc.createAccountUrl();\n          if (typeof accountUrl !== 'undefined') {\n            window.cordova.plugins.browsertab.openUrl(accountUrl);\n          } else {\n            throw 'Not supported by the OIDC server';\n          }\n        },\n\n        redirectUri(options) {\n          if (options && options.redirectUri) {\n            return options.redirectUri;\n          }\n          if (kc.redirectUri) {\n            return kc.redirectUri;\n          }\n          return 'http://localhost';\n        },\n      };\n    }\n\n    throw `invalid adapter type: ${type}`;\n  }\n\n  var LocalStorage = function () {\n    if (!(this instanceof LocalStorage)) {\n      return new LocalStorage();\n    }\n\n    localStorage.setItem('kc-test', 'test');\n    localStorage.removeItem('kc-test');\n\n    const cs = this;\n\n    function clearExpired() {\n      const time = new Date().getTime();\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.indexOf('kc-callback-') == 0) {\n          const value = localStorage.getItem(key);\n          if (value) {\n            try {\n              const { expires } = JSON.parse(value);\n              if (!expires || expires < time) {\n                localStorage.removeItem(key);\n              }\n            } catch (err) {\n              localStorage.removeItem(key);\n            }\n          }\n        }\n      }\n    }\n\n    cs.get = function (state) {\n      if (!state) {\n        return;\n      }\n\n      const key = `kc-callback-${state}`;\n      let value = localStorage.getItem(key);\n      if (value) {\n        localStorage.removeItem(key);\n        value = JSON.parse(value);\n      }\n\n      clearExpired();\n      return value;\n    };\n\n    cs.add = function (state) {\n      clearExpired();\n\n      const key = `kc-callback-${state.state}`;\n      state.expires = new Date().getTime() + 60 * 60 * 1000;\n      localStorage.setItem(key, JSON.stringify(state));\n    };\n  };\n\n  var CookieStorage = function () {\n    if (!(this instanceof CookieStorage)) {\n      return new CookieStorage();\n    }\n\n    const cs = this;\n\n    cs.get = function (state) {\n      if (!state) {\n        return;\n      }\n\n      const value = getCookie(`kc-callback-${state}`);\n      setCookie(`kc-callback-${state}`, '', cookieExpiration(-100));\n      if (value) {\n        return JSON.parse(value);\n      }\n    };\n\n    cs.add = function (state) {\n      setCookie(\n        `kc-callback-${state.state}`,\n        JSON.stringify(state),\n        cookieExpiration(60),\n      );\n    };\n\n    cs.removeItem = function (key) {\n      setCookie(key, '', cookieExpiration(-100));\n    };\n\n    var cookieExpiration = function (minutes) {\n      const exp = new Date();\n      exp.setTime(exp.getTime() + minutes * 60 * 1000);\n      return exp;\n    };\n\n    var getCookie = function (key) {\n      const name = `${key}=`;\n      const ca = document.cookie.split(';');\n      for (let i = 0; i < ca.length; i++) {\n        let c = ca[i];\n        while (c.charAt(0) == ' ') {\n          c = c.substring(1);\n        }\n        if (c.indexOf(name) == 0) {\n          return c.substring(name.length, c.length);\n        }\n      }\n      return '';\n    };\n\n    var setCookie = function (key, value, expirationDate) {\n      const cookie =\n        `${key}=${value}; ` + `expires=${expirationDate.toUTCString()}; `;\n      document.cookie = cookie;\n    };\n  };\n\n  function createCallbackStorage() {\n    try {\n      return new LocalStorage();\n    } catch (err) {}\n\n    return new CookieStorage();\n  }\n\n  function createLogger(fn) {\n    return function () {\n      if (kc.enableLogging) {\n        fn.apply(console, Array.prototype.slice.call(arguments));\n      }\n    };\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Keycloak);\n\n\n//# sourceURL=webpack://keycloak-code/./src/keycloak.js?");

/***/ })

/******/ });
});